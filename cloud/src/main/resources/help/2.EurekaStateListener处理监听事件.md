# 1.EurekaStateListener 是如何监听到消息的，是什么原理
`EurekaStateListener` 能“听到”注册中心里发生的所有上下线事件，**并不是自己去轮询，而是 Spring Cloud 在 Eureka-Server 内部发布的一系列 ApplicationEvent 被 `@EventListener` 捕获到了**。原理一句话：

> **Eureka-Server 把注册表的变化封装成 Spring 事件 → Spring 的 `ApplicationEventMulticaster` 把事件广播给所有 `@EventListener` 方法 → 我们的 `EurekaStateListener` 只要声明关心哪类事件，就能收到回调。**

下面按链路拆给你看：

1. 事件源（谁发的）  
   在 Eureka-Server 源码里，只要实例注册、下线、续约、集群同步完成，就会调一行：
   ```java
   publishEvent(new EurekaInstanceRegisteredEvent(this, info, lease, isReplication));
   ```
   或
   ```java
   publishEvent(new EurekaInstanceCanceledEvent(this, appName, serverId, isReplication));
   ```
   这些代码位于 `AbstractInstanceRegistry` / `PeerAwareInstanceRegistryImpl` 里，由 Spring-Cloud-Netflix 提供。

2. 事件广播（怎么传）  
   Spring Boot 启动时会自动注入一个 `ApplicationEventMulticaster`，它会把任意 `ApplicationEvent` 派发给所有 `@EventListener` 注解的方法。  
   因此我们写的：
   ```java
   @EventListener(condition = "#event.replication==false")
   public void listen(EurekaInstanceCanceledEvent event) { … }
   ```
   就会被注册成“消费者”。

3. 条件过滤（`condition` 作用）  
   `condition = "#event.replication==false"` 用的是 SpEL，**只消费“本机触发”的事件**，防止集群里别的节点同步过来时再重复发邮件。

4. 异步发送（`@Async`）  
   邮件发送方法打了 `@Async`，Spring 会用线程池去调，不会阻塞 Eureka 的注册/下线主流程。

5. 日志落盘  
   同一线程里顺手 `logger.info(...)`，内容就被前面配好的 `logback-spring.xml` 写到 `logs/` 目录。

总结：  
**“监听”本质是 Spring 的事件驱动模型**——Eureka-Server 负责发，Spring 负责播，我们只需声明 `@EventListener` 就能拿到回调，没有任何轮询、MQ 或额外接口。

# 2.ApplicationEventMulticaster是spring框架对象么？不是应用来创建和管理的？
`ApplicationEventMulticaster` 是 **Spring Framework 基础设施**，不是业务应用自己 new 出来的；  
它由 **Spring IoC 容器在启动阶段自动创建、自动配置、自动注入**，应用代码（包括我们自己写的 Listener）只负责“声明式”地用它，而**不需要也不应该**手动管理它的生命周期。

1. 谁创建  
   `AbstractApplicationContext#initApplicationEventMulticaster()`  
   在容器刷新（refresh）阶段被调用，如果发现 BeanFactory 里 **没有用户自定义**的 multicaster，就 new 一个 `SimpleApplicationEventMulticaster` 并注册成单例。

2. 谁注入  
   容器自己持有引用，后续所有 `publishEvent(...)` 都走到这个内部实例；我们写的 `@EventListener` 方法会被 `EventListenerMethodProcessor` 扫描并包装成 `ApplicationListener` 对象，然后注册到同一 multicaster 里。

3. 能不能替换  
   可以，但极少需要：  
   只要往容器里放一个名称为 `"applicationEventMulticaster"`、类型为 `ApplicationEventMulticaster` 的 Bean，Spring 就会用你提供的实现，否则走默认。

4. 应用层可见性  
   日常开发 99% 场景**感知不到它的存在**——我们只和 `@EventListener`、`ApplicationListener`、`@TransactionalEventListener` 打交道即可。

因此：
- 它是 **Spring 框架内部对象**；
- **生命周期归容器**；
- 应用代码**不需要自己 new、也不推荐手动管理**。

# 3.EurekaStateListener不添加@Component注解，里面的@EventListener注解标注的方法能监听到事件变更么？
不能。  
Spring 只会对**“容器里的 Bean”**去做 `@EventListener` 解析；没有 `@Component`（或任何能被 Spring 扫描并注册为 Bean 的注解/配置），`EurekaStateListener` 就根本不会被实例化，更谈不上把里面的方法注册到 `ApplicationEventMulticaster`。结果：事件广播时，回调表里找不到这个监听器，自然收不到任何事件。

验证步骤记忆一句话：  
**“@EventListener 只对标 Spring Bean；先成 Bean，才能成 Listener。”**