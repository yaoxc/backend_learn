### CEX交易流程拆分，从委托交易到订单撮合，到成交，有哪些阶段，每个阶段有什么中间件参与，给出主流实现方案，并列出关键步骤

CEX 从“委托”到“成交”可以拆成 4 个阶段、10 个关键步骤。  
每个阶段都有独立的高性能中间件负责横向扩展与故障隔离，主流方案在头部交易所（Binance、OKX、Coinbase 等）已工程化落地 。

---

### 阶段 1：订单接收 & 风控（毫秒级）
| 关键步骤 | 中间件/组件 | 主流实现要点 |
|---|---|---|
| ① 客户端下单 | WebSocket/TLS 网关 | Nginx/HAProxy 做 7 层负载均衡，防 DDoS；网关只做鉴权+限频，业务逻辑后置 |
| ② 风控 & 验资 | 风控微服务 + 本地缓存 | 采用 Lua 脚本在 Redis 中“余额预扣”，保证同一币种同一用户并发扣锁 <1 ms；风控规则（涨跌停、IP、黑名单）用 Drools/自研规则引擎 |
| ③ 订单入队 | Kafka/RabbitMQ | 顺序分区 key=symbol+side，保证同一交易对买卖单严格按时间序进入撮合；突发流量先写内存队列再刷盘，削峰填谷 |

---

### 阶段 2：撮合引擎（微秒级）
| 关键步骤 | 中间件/组件 | 主流实现要点 |
|---|---|---|
| ④ 订单簿维护 | 内存跳表（Skip List） | C++/Go 实现，价格层 O(log n) 插入/删除；热数据常驻内存，冷快照每 100 ms 异步落盘 |
| ⑤ 撮合 | 单线程无锁模型 | 每交易对独立线程，避免锁竞争；支持实时撮合+批量撮合两种模式（高流动性用实时，低流动性用 5-10 ms 批量） |
| ⑥ 成交事件生成 | Disruptor/自研环形队列 | 撮合线程只写内存环形队列，延迟 <10 µs；下游行情、账户、通知模块异步消费，实现 EDA（事件驱动架构） |

---

### 阶段 3：清算与账户更新（毫秒级）
| 关键步骤 | 中间件/组件 | 主流实现要点 |
|---|---|---|
| ⑦ 成交持久化 | TimescaleDB/InfluxDB | 时序表按 (symbol, trade_id) 分片，支持秒级聚合；写操作只追加无更新，保证高吞吐 |
| ⑧ 资金/持仓变更 | Redis + MySQL 两段提交 | 内存中“可用余额”立即扣减，异步任务把流水批量写 MySQL；失败时通过 Redis 回滚日志做补偿，保持最终一致 |
| ⑨ 通知推送 | WebSocket Gateway + MQTT | 撮合核心发“trade”事件到 Kafka，推送集群消费后 WebSocket 广播，端到端延迟 <50 ms |

---

### 阶段 4：结算与提现（分钟级）
| 关键步骤 | 中间件/组件 | 主流实现要点 |
|---|---|---|
| ⑩ 链上结算/提现 | 钱包节点 + 队列 | 内部账本与链上钱包解耦：先记账，再按币种归集到热/冷钱包；提现请求进入 Redis 优先级队列，风控二次审核后自动签名广播 |

---

### 一张图总结
```
客户端下单 → 网关 → 风控 → Kafka → 撮合引擎 → 成交事件 → 账户/行情/推送 → 结算
      ↑            ↑       ↑         ↑         ↑           ↑
   Nginx     Lua-Redis  SkipList  Disruptor  Timescale  Wallet
```

整体架构通过“无锁撮合 + 异步落库 + 事件驱动”实现高并发、低延迟，并保证任何单点故障可水平扩展或降级 。


