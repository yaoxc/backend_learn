结合交易所项目的微服务架构（钱包服务+RPC服务分工），**用户钱包地址生成的核心代码集中在「RPC服务」中**（负责区块链底层地址生成），钱包服务通过RestTemplate调用该RPC接口获取地址。以下是具体代码实现（分RPC服务端、钱包服务调用端），完全贴合项目实际业务逻辑：

## 一、核心原理
区块链地址生成的核心是 **“非对称加密算法”**（如以太坊用secp256k1曲线）：
1. 生成随机私钥（256位二进制数）；
2. 通过私钥计算公钥（椭圆曲线加密）；
3. 对公钥进行哈希处理（Keccak-256），截取后40位+前缀`0x`，得到最终地址。

项目中通过 **Web3j**（以太坊Java SDK）封装该过程，避免手动处理加密细节。

## 二、RPC服务端：地址生成核心代码（实际生成地址的地方）
RPC服务是独立微服务（注册名为`SERVICE-RPC`），提供地址生成接口，核心代码如下：

### 1. 配置类：初始化Web3j（区块链客户端）
```java
// RpcConfig.java（RPC服务的配置类）
@Configuration
public class RpcConfig {
    // 从配置文件读取以太坊节点RPC地址（如Infura、自建节点）
    @Value("${eth.rpc.url}")
    private String ethRpcUrl;

    // 初始化Web3j客户端（用于生成以太坊/ERC20 Token地址）
    @Bean
    public Web3j web3j() {
        // 创建HTTP客户端（也可支持WebSocket，视节点类型而定）
        return Web3j.build(new HttpService(ethRpcUrl));
    }
}
```

### 2. 服务类：封装地址生成逻辑
```java
// AddressGenerateService.java（RPC服务的业务类）
@Service
public class AddressGenerateService {
    private static final Logger logger = LoggerFactory.getLogger(AddressGenerateService.class);

    @Autowired
    private Web3j web3j;

    /**
     * 生成指定币种的钱包地址（支持ETH和ERC20 Token）
     * @param coinSymbol 币种符号（如ETH、USDT）
     * @return 钱包地址（含私钥加密存储信息，仅返回地址给调用方）
     */
    public String generateWalletAddress(String coinSymbol) throws Exception {
        // 1. 生成随机密钥对（私钥+公钥）：Web3j封装secp256k1算法
        ECKeyPair ecKeyPair = Keys.createEcKeyPair();
        BigInteger privateKey = ecKeyPair.getPrivateKey(); // 私钥（需加密存储）
        String address = "0x" + Keys.getAddress(ecKeyPair); // 公钥→地址（自动处理哈希和截取）

        logger.info("生成 {} 钱包地址：{}，私钥（加密前）：{}", coinSymbol, address, privateKey.toString(16));

        // 2. 加密私钥（关键！不能明文存储，用AES加密后存入数据库）
        String encryptedPrivateKey = encryptPrivateKey(privateKey.toString(16));

        // 3. 存储地址+加密私钥到RPC服务的数据库（后续签名交易时使用）
        WalletRecord walletRecord = WalletRecord.builder()
                .coinSymbol(coinSymbol)
                .address(address)
                .encryptedPrivateKey(encryptedPrivateKey)
                .createTime(new Date())
                .status(1) // 地址状态：可用
                .build();
        walletRecordRepository.save(walletRecord);

        // 4. 仅返回地址给调用方（钱包服务），私钥不对外暴露
        return address;
    }

    /**
     * AES加密私钥（防止私钥泄露，密钥从配置文件读取，需定期轮换）
     * @param privateKey 明文私钥（16进制字符串）
     * @return 加密后的私钥
     */
    private String encryptPrivateKey(String privateKey) throws Exception {
        // 从配置文件读取AES密钥和偏移量（生产环境需配置在配置中心，如Nacos/Apollo）
        @Value("${wallet.private-key.aes.key}")
        String aesKey; // 16位（AES-128）或32位（AES-256）
        @Value("${wallet.private-key.aes.iv}")
        String aesIv; // 16位

        // 使用AES/CBC/PKCS5Padding模式加密
        Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
        SecretKeySpec keySpec = new SecretKeySpec(aesKey.getBytes(StandardCharsets.UTF_8), "AES");
        IvParameterSpec ivSpec = new IvParameterSpec(aesIv.getBytes(StandardCharsets.UTF_8));
        cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);

        byte[] encryptedBytes = cipher.doFinal(privateKey.getBytes(StandardCharsets.UTF_8));
        return Base64.getEncoder().encodeToString(encryptedBytes); // Base64编码后存储
    }
}
```

### 3. 控制器：提供RPC接口（供钱包服务调用）
```java
// AddressRpcController.java（RPC服务的接口层）
@RestController
@RequestMapping("/rpc/address")
public class AddressRpcController {
    @Autowired
    private AddressGenerateService addressGenerateService;

    /**
     * 生成钱包地址的RPC接口
     * @param coinSymbol 币种符号（如ETH、USDT）
     * @return 统一返回格式（MessageResult）
     */
    @GetMapping("/create")
    public MessageResult<String> createAddress(@RequestParam String coinSymbol) {
        try {
            // 校验币种是否支持（从数据字典查询）
            boolean support = coinService.checkCoinSupport(coinSymbol);
            if (!support) {
                return MessageResult.error(400, "不支持该币种的地址生成");
            }

            // 生成地址
            String address = addressGenerateService.generateWalletAddress(coinSymbol);
            return MessageResult.success("地址生成成功", address);
        } catch (Exception e) {
            logger.error("生成 {} 地址失败", coinSymbol, e);
            return MessageResult.error(500, "地址生成失败：" + e.getMessage());
        }
    }
}
```

## 三、钱包服务调用端：调用RPC接口获取地址（对应之前的`MemberConsumer`）
钱包服务不直接生成地址，而是通过RestTemplate调用RPC服务的接口，核心代码如下（补充`MemberConsumer`中`createUserWallet`方法的底层调用逻辑）：

### 1. 配置类：RestTemplate（负载均衡）
```java
// RestTemplateConfig.java（钱包服务的配置类）
@Configuration
public class RestTemplateConfig {
    @Bean
    @LoadBalanced // 启用Spring Cloud负载均衡，支持通过服务名调用RPC集群
    public RestTemplate restTemplate() {
        RestTemplate restTemplate = new RestTemplate();
        // 设置超时时间（避免RPC服务响应慢导致阻塞）
        SimpleClientHttpRequestFactory factory = new SimpleClientHttpRequestFactory();
        factory.setConnectTimeout(3000); // 连接超时3秒
        factory.setReadTimeout(5000);    // 读取超时5秒
        restTemplate.setRequestFactory(factory);
        return restTemplate;
    }
}
```

### 2. 调用逻辑（`MemberConsumer`中的核心方法）
```java
// MemberConsumer.java（钱包服务的Kafka消费者）
@Component
public class MemberConsumer {
    private static final Logger logger = LoggerFactory.getLogger(MemberConsumer.class);

    @Autowired
    private RestTemplate restTemplate;

    @Autowired
    private AccountService accountService;

    // RPC服务的注册名（Eureka中配置）
    private static final String RPC_SERVICE_NAME = "SERVICE-RPC";

    /**
     * 为用户生成单个币种的钱包地址（调用RPC服务）
     */
    private void createUserWallet(Long userId, String username, Coin coin) {
        try {
            // 1. 构造RPC接口地址（通过服务名调用，负载均衡到RPC集群）
            String rpcUrl = String.format("http://%s/rpc/address/create?coinSymbol=%s",
                    RPC_SERVICE_NAME, coin.getSymbol());

            // 2. 调用RPC接口，获取地址
            MessageResult<String> result = restTemplate.getForObject(rpcUrl, MessageResult.class);

            // 3. 处理RPC返回结果
            if (result == null || !result.isSuccess()) {
                String errorMsg = result != null ? result.getMessage() : "RPC服务无响应";
                logger.error("用户 {} 的 {} 地址生成失败：{}", userId, coin.getSymbol(), errorMsg);
                return;
            }

            String walletAddress = result.getData(); // RPC返回的钱包地址（如0x123456...）

            // 4. 保存用户-地址关联关系到钱包服务的数据库（MySQL）
            Account account = Account.builder()
                    .userId(userId)
                    .username(username)
                    .coinId(coin.getId())
                    .coinSymbol(coin.getSymbol())
                    .address(walletAddress)
                    .balance(BigDecimal.ZERO) // 初始余额0
                    .status(1) // 正常状态
                    .createTime(new Date())
                    .build();
            accountService.save(account);

            logger.info("用户 {} 成功创建 {} 钱包，地址：{}", userId, coin.getSymbol(), walletAddress);

        } catch (Exception e) {
            logger.error("用户 {} 的 {} 钱包创建失败", userId, coin.getSymbol(), e);
            // 可选：存入重试队列，后续定时重试（避免因网络波动导致创建失败）
        }
    }
}
```

## 四、关键补充说明（生产环境必须关注）
### 1. 私钥安全存储
- 绝对不能明文存储私钥！代码中通过AES加密后存入数据库，密钥需配置在**配置中心**（如Nacos/Apollo），而非本地配置文件；
- 加密模式推荐`AES-256-CBC`，密钥长度32位，偏移量（IV）16位，且IV需随机生成（生产环境可优化`encryptPrivateKey`方法，每次生成随机IV并与密文一起存储）。

### 2. 地址唯一性保障
- RPC服务的`wallet_record`表需添加`address`字段唯一索引，防止重复生成相同地址；
- 钱包服务的`account`表通过`(userId, coinId)`组合唯一索引，确保“一户一币种一地址”。

### 3. 多币种适配
- 若支持其他区块链（如BTC），需替换地址生成逻辑（BTC用secp256k1+Base58Check编码），可通过策略模式扩展：
  ```java
  // 策略模式示例：不同币种的地址生成策略
  public interface AddressGenerateStrategy {
      String generate();
  }

  // ETH地址生成策略
  public class EthAddressStrategy implements AddressGenerateStrategy { ... }

  // BTC地址生成策略
  public class BtcAddressStrategy implements AddressGenerateStrategy { ... }
  ```

### 4. 异常重试机制
- 网络波动或RPC服务临时不可用时，需添加重试逻辑（如使用`Spring Retry`），避免用户注册后钱包创建失败；
- 重试次数建议3次，间隔1秒，重试失败后存入数据库重试队列，人工介入处理。

## 五、总结
项目中生成用户钱包地址的核心流程：
1. 钱包服务监听用户注册Kafka消息；
2. 调用RPC服务的`/rpc/address/create`接口，传入币种符号；
3. RPC服务通过Web3j生成密钥对，加密私钥后存储，返回地址；
4. 钱包服务保存用户-地址关联关系，完成钱包创建。

核心代码集中在 **RPC服务的`AddressGenerateService`**（地址生成+私钥加密）和 **钱包服务的`MemberConsumer`**（接口调用+关联存储），既保证了区块链底层逻辑的封装隔离，又通过微服务调用实现了高可用扩展。