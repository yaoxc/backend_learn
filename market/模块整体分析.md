# 项目整体介绍

下面给出一份“自下而上”的代码地图：先逐文件说明它“做什么”，再画出它们“如何被串起来”完成行情/推送/持久化这一条龙服务。最后给出一张精简业务流程图，一眼就能看清数据从撮合到客户端的完整路径。

------------------------------------------------
一、30 个文件职能速查表
------------------------------------------------
| 文件 | 主要功能 | 在项目中的角色 |
|---|---|---|
| 1. ApplicationEvent | 监听 Spring 容器刷新事件，启动时把所有已启用交易对的 CoinProcessor 初始化（开盘快照、USD 汇率、置为不停牌） | 系统启动“点火器” |
| 2. CoinExchangeRate | 管理 USDT/CNY、USD/CNY 等基准汇率；提供 `getUsdRate(symbol)` 算法：先查 USDT 交易对，没有再查 BTC/ETH，最后 fallback 到数据库默认值；带 @Scheduled 爬虫方法（已注释） | 全系统价格“度量衡” |
| 3. ContextConfig | 全局跨域过滤器 | 让前端 / APP 可调接口 |
| 4. KafkaConsumerConfig | 批量并发消费配置（批量拉、手动提交、并发线程数、超时） | 所有消费者公共模板 |
| 5. KafkaProducerConfig | 生产者批处理、重试、缓冲区配置 | 所有生产者公共模板 |
| 6. ProcessorConfig | 在 Spring 启动阶段：① 查询数据库中所有启用的交易对 ② 为每个交易对 new 一个 DefaultCoinProcessor ③ 把 Mongo/WebSocket/Netty 三个 Handler 串到处理器上 ④ 把工厂回灌给 CoinExchangeRate | 行情处理器“装配车间” |
| 7. RestTemplateConfig | 带 @LoadBalanced 的 RestTemplate | 调用撮合中心 / 远程服务 |
| 8. WebSocketConfig | STOMP 端点 /topic、/app 前缀配置 | H5/浏览器 WebSocket 握手 |
| 9. DataDictionarySaveUpdateConsumer | 监听后台“数据字典变更”Topic，同步刷新 Redis 缓存 | 运营后台改配置实时生效 |
|10. ExchangeTradeConsumer | 核心消费者：同时监听 5 个 Topic（成交、盘口、订单完成、撤单成功、模拟盘）→ 把数据交给对应 CoinProcessor 并推送 | 撮合→行情“总调度” |
|11. ExchangeRateController | REST：/exchange-rate/usd/{coin}、/usdtcny 等 | 汇率 HTTP 查询口 |
|12. MarketController | REST：/symbol、/symbol-thumb、/history、/latest-trade、/exchange-plate 等 | 行情 HTTP 查询口 |
|13. TradeRepository | MongoRepository<ExchangeTrade,Long> | 成交明细 DAO（实际未直接使用，由 MongoTemplate 替代） |
|14. MarketHandler | 接口：handleTrade / handleKLine | 责任链模式，方便横向扩展存储/推送 |
|15. MongoMarketHandler | 把 Trade 写到 exchange_trade_{symbol}，把 KLine 写到 exchange_kline_{symbol}_{period} | 持久化 |
|16. NettyHandler | ① 维护 Channel→Topic 映射 ② 把行情/盘口/订单/深度推送给 APP 长连接 | 移动端网关 |
|17. WebsocketMarketHandler | 把 Thumb/KLine 推送到 /topic/market/* | 浏览器网关 |
|18. CoinProcessorJob | 每 1 分钟轮询“撮合中心 /monitor/engines”接口：① 发现新增交易对→动态创建 Processor ② 发现状态由 1→2 或 2→1→动态启停 KLine 生成 | 动态扩缩容 |
|19. ExchangePushJob | 内存队列 + 定时批推：tradesQueue/ plateQueue/ thumbQueue 每 0.5 s/2 s 批量 WebSocket/Netty 推送 | 削峰填谷、降低推送频次 |
|20. KLineGeneratorJob | 每分钟/小时/日触发，调用 CoinProcessor.generateKLine 合并 1 min KLine 成 5 min/1 h/1 d 等更高周期 | 周期 K 线生成器 |
|21. MarketApplication | @SpringBootApplication + @EnableScheduling | 启动类 |
|22. ChannelSet | 原生 Netty Channel 池（add/remove） | 被 NettyHandler 使用，维护长连接 |
|23. QuoteMessage | Protobuf 生成的 POJO（SimpleResponse） | Netty 二进制协议包 |
|24. CoinProcessor | 接口：process/trades、generateKLine、initializeThumb、setIsHalt… | 定义“交易对处理器”标准 |
|25. CoinProcessorFactory | ConcurrentHashMap 缓存所有交易对处理器 | 工厂 + 单例池 |
|26. DefaultCoinProcessor | 接口核心实现：① process 逐笔更新 1 min KLine & CoinThumb ② generateKLine 按周期聚合 ③ initializeThumb 计算 24 h 开盘/最高/最低/成交量 | 行情“发动机” |
|27. MarketService | 封装 MongoTemplate 查询：findAllKLine、findTradeByTimeRange、findTradeVolume、saveKLine… | 数据访问服务 |
|28~30 | 实体类（省略） | ExchangeTrade、KLine、CoinThumb、TradePlate… |

------------------------------------------------
二、全局协作关系（文字版流程）
------------------------------------------------
1. 启动  
   ApplicationEvent → 调用 ProcessorConfig → 为每个已启用交易对 new DefaultCoinProcessor → 注册到 CoinProcessorFactory → 初始化 Thumb & USD 汇率。

2. 输入  
   撮合引擎每产生一笔成交/盘口/订单事件 → 发送到 Kafka（topics: exchange-trade / exchange-trade-plate / exchange-order-completed …）。

3. 消费  
   ExchangeTradeConsumer 批量拉取 →
    - 交/易明细 → 交给对应 CoinProcessor.process(List<ExchangeTrade>)
    - 盘        口 → pushJob.addPlates()
    - 订单状态 → WebSocket/Netty 直接推送

4. 处理  
   DefaultCoinProcessor：  
   a) process() → 逐笔更新 current 1 min KLine + CoinThumb（开高低收、成交量、涨跌幅）  
   b) 把 ExchangeTrade 沿责任链抛给 MongoMarketHandler（持久化）+ WebsocketMarketHandler（推送 Thumb）+ NettyHandler（推送 Trade）

5. 周期  
   KLineGeneratorJob：
    - 每分钟触发 → autoGenerate() 把 current 1 min KLine 落库并新建下一根
    - 5 min/15 min/1 h/1 d 等周期到点时 → generateKLine() 聚合落库

6. 推送  
   ExchangePushJob：
    - 0.5 s 批推成交 / Thumb
    - 2 s 批推盘口深度  
      → WebSocket（浏览器） + Netty（APP） 双通道广播

7. 查询  
   MarketController / ExchangeRateController 提供 HTTP 接口，读 CoinProcessorFactory 里最新 Thumb 或 CoinExchangeRate 汇率即时返回。

8. 动态  
   CoinProcessorJob 每 1 分钟拉撮合中心 /monitor/engines：
    - 发现新币对 → 动态创建 Processor
    - 发现状态变 2 → 停止 KLine 生成
    - 发现状态变 1 → 恢复生成

------------------------------------------------
三、精简业务流程图
------------------------------------------------
```
撮合引擎
   │
   ├─Kafka──exchange-trade──────────────┐
   ├─Kafka──exchange-trade-plate──────┐ │
   ├─Kafka──exchange-order-completed──┐ │ │
   …                                  │ │ │
                                      ▼ ▼ ▼
                          ExchangeTradeConsumer（批量）
                                      │
                   ┌──────────────────┼──────────────────┐
                   │                  │                  │
            CoinProcessor.process()  pushJob.addPlates  直接推送订单
                   │                  │                  │
           ┌───────▼──────┐     ┌─────▼─────┐     ┌─────▼─────┐
           │MongoMarketHandler│ │WS/Netty推送 │ │订单私有通道 │
           │(持久化)        │ │(Thumb/Trade)│ │(Web/Netty) │
           └───────┬──────┘     └─────┬─────┘     └─────┬─────┘
                   │                  │                  │
           ┌───────▼──────────────────┼──────────────────┼────────────┐
           │   ExchangePushJob（0.5 s/2 s 批推）        │            │
           │   WebSocket:/topic/market/trade /plate/thumb │            │
           │   Netty: 长连接二进制推送                    │            │
           └──────────────────┬────────────────────────────┘            │
                              │                                         │
                              ▼                                         ▼
                     浏览器/APP 实时行情展示                    个人中心即时成交通知
```

------------------------------------------------
四、一句话总结
------------------------------------------------
> “撮合把事件发到 Kafka → ExchangeTradeConsumer 分发给各交易对的 DefaultCoinProcessor → 处理器更新内存 K 线/Thumb 并沿责任链写 Mongo、推 WebSocket、推 Netty → 周期任务生成高周期 K 线 → 推送任务批量广播 → 前端/APP 实时看到最新行情与委托回报”。整个系统完全事件驱动、无中心调度器，靠 Kafka+Spring 事件+定时任务完成高并发、低延迟的行情与推送服务。

# exchange-trade、exchange-trade-plate、exchange-order-completed事件是在什么场景下发出的


| 事件 | 触发源（哪段代码） | 典型场景（什么情况下一定会发） | 消息体内容 | 下游用途 |
|---|---|---|---|---|
| **exchange-trade** | `ExchangeCoinServiceImpl#processExchangeTrade()` 或 `ExchangeCoinServiceImpl#matchSuccess()` | ① 撮合引擎产生一笔 **已完全成交** 的明细（无论吃单是否全部成交）<br>② 后台撤单时部分已成交，先把已成交部分落库后也会发 | `List<ExchangeTrade>`（多笔合并批） | 1. 更新 K 线、24 h 统计<br>2. 持久化到 Mongo<br>3. 向双方用户推送“您的订单已成交” |
| **exchange-trade-plate** | `TradePlateService#refreshPlate()` / `TradePlateService#removeOrder()` | ① 有新订单进入深度导致买/卖档位变化 ≥ 1 档<br>② 撤单导致档位消失或数量变化<br>③ 撮合成交后档位被吃掉需要重建 | `TradePlate` 对象（当前买 24 档+卖 24 档快照） | 1. 前端深度图实时刷新<br>2. APP 盘口列表<br>3. 机器人策略计算 |
| **exchange-order-completed** | `ExchangeOrderService#orderCompleted()` | 当某条委托 **剩余数量 = 0** 时（全部成交或撤单完成）且状态机从“部分成交/待成交”→“已完成” | `List<ExchangeOrder>`（已完成订单批） | 1. 向订单所属用户推送“订单已完成”<br>2. 更新数据库状态<br>3. 触发返佣、活动、量化策略等后续业务 |

### 一句话记忆：
- **exchange-trade** = “每一口成交”都会发；
- **exchange-trade-plate** = “深度档位变了”就发；
- **exchange-order-completed** = “整条订单生命周期结束”才发。

# DefaultCoinProcessor作用是什么

`DefaultCoinProcessor` 是“**一个交易对、一个实例**”的**行情发动机**，负责把撮合产生的原始成交数据加工成**实时 K 线**、**24 h 行情快照（CoinThumb）**，并驱动**持久化**与**多端推送**。一句话：**它让一条原始成交记录变成用户看到的分时图、盘口、涨跌幅和深度图**。

------------------------------------------------
一、核心职责（官方接口 `CoinProcessor` 的实现）
------------------------------------------------
1. 逐笔消费成交  
   `process(List<ExchangeTrade>)`
    - 更新当前 **1 min K 线**（开高低收、成交量、成交额）
    - 更新 **CoinThumb**（24 h 开高低收、涨跌幅、成交量、USD 汇率）
    - 沿责任链抛给：  
      – `MongoMarketHandler` → 写 Mongo  
      – `WebsocketMarketHandler` → 推 /topic/market/thumb  
      – `NettyHandler` → 推 APP 长连接

2. 周期生成多周期 K 线  
   `generateKLine(5, Calendar.MINUTE, time)` …
    - 按 5 min/15 min/1 h/1 d 等粒度**聚合 1 min K 线**
    - 落库 `exchange_kline_{symbol}_{period}`
    - 供 K 线图表、技术指标、后台量化使用

3. 开盘/重启初始化  
   `initializeThumb()`
    - 从 Mongo 拉当日 0 点至今的 1 min K 线，重建 24 h 开盘价、最高、最低、成交量  
      `initializeUsdRate()`
    - 根据基准币 USDT/BTC/ETH 汇率，计算并缓存 `usdRate` 字段，供前端换算

4. 交易对生命周期控制  
   `setIsHalt(boolean)`          // 临时暂停/恢复计算  
   `setIsStopKLine(boolean)`     // 停止/启动周期 K 线生成（用于后台“停牌”）

------------------------------------------------
二、内部关键数据结构
------------------------------------------------
- `currentKLine`：当前正在写入的 1 min 蜡烛
- `coinThumb`：24 h 滚动行情快照（开、高、低、收、量、涨跌幅、USD 价格）
- `handlers`：责任链列表，动态注入 Mongo/WebSocket/Netty 三种 Handler
- `coinExchangeRate`：注入的汇率组件，用于把非 USDT 市场折算成 USD

------------------------------------------------
三、典型时间线（一条成交记录的一生）
------------------------------------------------
1. 撮合引擎产生 `ExchangeTrade` → Kafka → `ExchangeTradeConsumer`
2. 消费者拿到后调 `CoinProcessorFactory.getProcessor("BTC/USDT").process(trades)`
3. `DefaultCoinProcessor.process()`：  
   a) 加锁更新 `currentKLine` 开高低收、量、额  
   b) 加锁更新 `coinThumb` 24 h 高/低/量/涨跌幅  
   c) 回调责任链：
    - `MongoMarketHandler` 写 `exchange_trade_BTC/USDT`
    - `WebsocketMarketHandler` 把最新 `CoinThumb` 扔进 `ExchangePushJob.thumbQueue`
    - `NettyHandler` 把 `ExchangeTrade` 推给订阅了 `BTC/USDT` 的 APP
4. 1 min 到点 → `KLineGeneratorJob` 触发 → `autoGenerate()`：
    - 把 `currentKLine` 落库 → new 下一根 1 min K 线
5. 5 min 到点 → `generateKLine(5, MINUTE)` 聚合最近 5 根 1 min 落库 `exchange_kline_BTC/USDT_5min`

------------------------------------------------
四、再浓缩成一句话
------------------------------------------------
`DefaultCoinProcessor` 就是**绑定在某个交易对上的“实时行情小引擎”**：  
“**吃进的每一笔成交都会立刻刷新 1 min K 线和 24 h 快照，并顺手把数据丢给 Mongo、WebSocket、Netty，让图表、深度、涨跌幅、APP 推送同时更新**”。

# CoinTrader的作用是什么

`CoinTrader` 是**撮合引擎**的**“单币对撮合容器”**，一个交易对（symbol）对应一个 `CoinTrader` 实例。  
它的核心使命只有一句话：

> **“把来自全网用户的买单、卖单放在自己的订单簿里，价格吻合就立即生成成交记录，并通知后续业务。”**

---

### 一、在架构中的位置
```
用户下单 → 撮合网关 → Kafka → 撮合消费线程 → 路由到对应 CoinTrader  
                                                     ↓  
                                              OrderBook（买/卖深度）  
                                                     ↓  
                                              撮合成交 → 返回 ExchangeTrade  
                                                     ↓  
                                              写 Kafka（exchange-trade / exchange-trade-plate / ...）
```

---

### 二、内部关键结构
| 字段/对象 | 作用 |
|---|---|
| `TreeMap<BigDecimal, List<ExchangeOrder>> buyBook` | 买单深度（价格降序） |
| `TreeMap<BigDecimal, List<ExchangeOrder>> sellBook` | 卖单深度（价格升序） |
| `boolean tradingHalt = false` | **“停牌开关”**：`true` 时暂停撮合，仅接受撤单。 |
| `match()` | 核心撮合算法：新订单进来与对手盘逐级成交，直到无价格交叉或本单完全成交。 |
| `placeOrder()` | 下单入口，先尝试立即成交，剩余量写入订单簿。 |
| `cancelOrder()` | 撤单入口，从订单簿移除并返回剩余量。 |

---

### 三、典型生命周期
1. **启动**  
   撮合服务启动时为每个**已启用**交易对 `new CoinTrader(symbol)`，并定时 `synchronizeExchangeCenter()`（见 `CoinProcessorJob`）发现新币对时动态创建。

2. **下单**
    - 用户输入限价/市价单 → 网关 → Kafka → 撮合消费者 → `coinTrader.placeOrder(order)`
    - `match()` 生成 **N 笔** `ExchangeTrade` → 写 `exchange-trade` Topic
    - 剩余量写入订单簿 → 写 `exchange-trade-plate` Topic（深度变化）

3. **撤单**
    - 用户撤单 → `coinTrader.cancelOrder(orderId)`
    - 从 `buyBook/sellBook` 移除 → 写 `exchange-order-cancel-success` Topic
    - 深度变化 → 再次发 `exchange-trade-plate`

4. **停牌/复牌**  
   运营后台点击“暂停交易” → 调 `coinTrader.haltTrading()`（`tradingHalt=true`），此时：
    - 不再撮合，新订单直接返回“交易对已暂停”
    - 撤单仍允许  
      点击“恢复” → `coinTrader.resumeTrading()`（`tradingHalt=false`），撮合继续。

---

### 四、与外围的交互
| 交互方 | 方向 | 数据 |
|---|---|---|
| **Kafka 消费者**（撮合线程） | 输入 | 下单、撤单指令 |
| **Kafka 生产者** | 输出 | `exchange-trade`、`exchange-trade-plate`、`exchange-order-completed` |
| **数据库** | 输出 | 落库订单、成交（由下游 consumer 完成，CoinTrader 只写 Kafka） |
| **后台管理** | 输入 | `haltTrading()` / `resumeTrading()` |

---

### 五、一句话总结
`CoinTrader` 就是**“一个交易对的私有撮合引擎”**：  
**“维护买卖订单簿，价格对得上就立即成交并广播成交记录，同时提供撤单和停牌接口，是行情与深度数据的唯一源头。”**








