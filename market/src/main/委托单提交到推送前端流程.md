# `用户提交委托单 → 撮合成功 → 入库/推送`以及`订单取消`两条完整链路


### 一、委托成交完整链路（用户下单 → 撮合 → 入库/推送）

```
1. 前端/APP POST /order/add
   └─ OrderController.addOrder()
      ├─ 风控、余额、精度、活动期校验
      ├─ orderService.addOrder()  落库
      └─ kafkaTemplate.send("exchange-order", JSON订单)
         【OrderController.java】

2. Kafka  topic = exchange-order
   └─ ExchangeOrderConsumer.onOrderSubmitted()
      ├─ 反序列化 ExchangeOrder
      ├─ 检查 trader.isTradingHalt() / trader.getReady()
      ├─ 若未就绪 → send("exchange-order-cancel-success") 并返回
      └─ 若就绪 → coinTrader.trade(order)
         【ExchangeOrderConsumer.java】

3. CoinTrader.trade(ExchangeOrder)  【CoinTrader.java】
   ├─ 路由到 matchLimitPriceWithLPList() / matchMarketPriceWithLPList()
   ├─ 循环调用 processMatch() 生成 ExchangeTrade
   ├─ handleExchangeTrade(List<ExchangeTrade>)
   │   └─ kafka.send("exchange-trade", trades)
   ├─ orderCompleted(List<ExchangeOrder>)
   │   └─ kafka.send("exchange-order-completed", orders)
   └─ sendTradePlateMessage(TradePlate)
       └─ kafka.send("exchange-trade-plate", plate)

4. Kafka 下游消费
   ├─ exchange-trade
   │   └─ ExchangeTradeConsumer.handleTrade()
   │       ├─ exchangeOrderService.processExchangeTrade()  成交明细落库
   │       ├─ CoinProcessor.process()  更新K线、指标
   │       ├─ pushJob.addTrades()  行情缓存
   │       └─ messagingTemplate + nettyHandler  推送用户成交消息
   ├─ exchange-order-completed
   │   └─ ExchangeTradeConsumer.handleOrderCompleted()
   │       ├─ exchangeOrderService.tradeCompleted()  更新订单状态、冻结资金
   │       └─ WebSocket & Netty 推送“订单已完成”事件
   └─ exchange-trade-plate
       └─ ExchangeTradeConsumer.handleTradePlate()
           ├─ pushJob.addPlates()  深度缓存
           └─ WebSocket & Netty 推送实时买卖墙

5. 前端/APP 收到推送
   ├─ /topic/market/order-trade/{symbol}/{uid}     个人成交片段
   ├─ /topic/market/order-completed/{symbol}/{uid} 个人订单完成
   ├─ /topic/market/kline/{symbol}                 K线更新
   └─ /topic/market/order-canceled/{symbol}/{uid}  取消成功（见下）
```

---

### 二、订单取消链路（用户撤单 → 内存删除 → 资金解锁 → 推送）

```
1. 前端 POST /order/cancel/{orderId}
   └─ OrderController.cancelOrder()
      ├─ 归属校验、状态校验、清盘期校验
      ├─ 若引擎内存中不存在 → forceCancelOrder() 直接数据库撤单
      └─ 若存在 → kafkaTemplate.send("exchange-order-cancel", order)

2. Kafka topic = exchange-order-cancel
   └─ ExchangeOrderConsumer.onOrderCancel()
      ├─ trader.cancelOrder(order)  从内存队列删除
      ├─ 返回结果非空 → send("exchange-order-cancel-success")
      └─ 异常 → 仅记录日志

3. Kafka topic = exchange-order-cancel-success
   └─ ExchangeTradeConsumer.handleOrderCanceled()
      ├─ exchangeOrderService.cancelOrder()  状态→CANCELED，资金解锁
      ├─ messagingTemplate.convertAndSend  WebSocket推送用户
      └─ nettyHandler.handleOrder(PUSH_EXCHANGE_ORDER_CANCELED)  Netty推送

4. 前端/APP 收到
   └─ /topic/market/order-canceled/{symbol}/{uid}  撤单成功通知
```

---

### 三、关键类 & 方法速查

| 阶段 | 类 | 关键方法 | 文件 |
|------|----|----------|------|
| 下单校验 | OrderController | addOrder() | OrderController.java |
| 订单进撮合 | ExchangeOrderConsumer | onOrderSubmitted() | ExchangeOrderConsumer.java |
| 撮合核心 | CoinTrader | trade() / processMatch() | CoinTrader.java |
| 成交落库 | ExchangeTradeConsumer | handleTrade() | ExchangeTradeConsumer.java |
| 订单完成 | ExchangeTradeConsumer | handleOrderCompleted() | ExchangeTradeConsumer.java |
| 撤单 | OrderController | cancelOrder() | OrderController.java |
| 撤单消费 | ExchangeOrderConsumer | onOrderCancel() | ExchangeOrderConsumer.java |
| 撤单完成 | ExchangeTradeConsumer | handleOrderCanceled() | ExchangeTradeConsumer.java |
| WebSocket 推送 | SimpMessagingTemplate | convertAndSend(...) | 配置注入 |
| Netty 推送 | NettyHandler | handleOrder() | NettyHandler.java |

---

### 四、一句话总结

> **「下单-撮合-入库-推送」与「撤单-删队列-解锁-推送」两条流水线完全通过 Kafka 解耦，CoinTrader 只负责内存撮合，所有持久化与前端实时数据均由下游 Consumer 完成，保证高可用与水平扩展。**














